// Code for managing Script Info of ASS/SSA files
// https://fileformats.fandom.com/wiki/SubStation_Alpha#Script_Info_section

// Example of .ass Script Info section:
// [Script Info]
// ; Script generated by Aegisub 2.1.8
// ; http://www.aegisub.org/
// Title: Default Aegisub file
// ScriptType: v4.00+
// WrapStyle: 0
// PlayResX: 1280
// PlayResY: 720
// ScaledBorderAndShadow: yes
// Collisions: Normal
// Video Aspect Ratio: 0
// Video Zoom: 2
// Original Script: name
// Original Translation: name
// Original Editing: name
// Original Timing: name
// Synch Point: 0
// Script Updated By: name
// Update Details: details
// YCbCr Matrix: TV.709

use std::{
    fmt,
    num::{ParseFloatError, ParseIntError},
    str::FromStr,
};

use log;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum MalformedScriptInfoError {
    #[error("could not parse style value")]
    ParseError,
}

impl From<ParseIntError> for MalformedScriptInfoError {
    fn from(_error: ParseIntError) -> Self {
        MalformedScriptInfoError::ParseError
    }
}

impl From<ParseFloatError> for MalformedScriptInfoError {
    fn from(_error: ParseFloatError) -> Self {
        MalformedScriptInfoError::ParseError
    }
}

pub struct ScriptInfo {
    pub comments: Option<String>,
    pub title: Option<String>,
    pub script_type: Option<String>,
    pub wrap_style: Option<u8>,
    pub play_res_x: Option<u16>,
    pub play_res_y: Option<u16>,
    pub scaled_border_and_shadow: Option<bool>, // True = yes, False = no
    // Collisions is dropped in Aegisub 3.0.2 but may still exist in .ass files
    pub collisions: Option<String>, // "Normal" or "Reverse"
    pub video_aspect_ratio: Option<f32>,
    pub video_zoom: Option<u8>,
    // Used very rarely:
    pub original_script: Option<String>,
    pub original_translation: Option<String>,
    pub original_editing: Option<String>,
    pub original_timing: Option<String>,
    pub synch_point: Option<u8>,
    pub script_updated_by: Option<String>,
    pub update_details: Option<String>,
    pub ycbcr_matrix: Option<String>,
}

impl Default for ScriptInfo {
    fn default() -> ScriptInfo {
        ScriptInfo {
            comments: None,
            title: Some(String::from("Default Aegisub file")),
            script_type: Some(String::from("v4.00+")),
            wrap_style: None,
            play_res_x: None,
            play_res_y: None,
            scaled_border_and_shadow: None,
            collisions: None,
            video_aspect_ratio: None,
            video_zoom: None,
            original_script: None,
            original_translation: None,
            original_editing: None,
            original_timing: None,
            synch_point: None,
            script_updated_by: None,
            update_details: None,
            ycbcr_matrix: None,
        }
    }
}

impl fmt::Display for ScriptInfo {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let mut string_data = String::with_capacity(450); // Roughly the amount of bytes when using all script parameters

        string_data.push_str("[Script Info]\n");
        if self.comments.is_some() {
            string_data.push_str(&format!("{}\n", self.comments.as_ref().unwrap()));
        }
        if self.title.is_some() {
            string_data.push_str(&format!("Title: {}\n", self.title.as_ref().unwrap()));
        }
        if self.script_type.is_some() {
            string_data.push_str(&format!(
                "ScriptType: {}\n",
                self.script_type.as_ref().unwrap()
            ));
        }
        if self.wrap_style.is_some() {
            string_data.push_str(&format!(
                "WrapStyle: {}\n",
                self.wrap_style.as_ref().unwrap()
            ));
        }
        if self.play_res_x.is_some() {
            string_data.push_str(&format!(
                "PlayResX: {}\n",
                self.play_res_x.as_ref().unwrap()
            ));
        }
        if self.play_res_y.is_some() {
            string_data.push_str(&format!(
                "PlayResY: {}\n",
                self.play_res_y.as_ref().unwrap()
            ));
        }
        if self.scaled_border_and_shadow.is_some() {
            string_data.push_str(&format!(
                "ScaledBorderAndShadow: {}\n",
                if *self.scaled_border_and_shadow.as_ref().unwrap() {
                    "yes"
                } else {
                    "no"
                }
            ));
        }
        if self.collisions.is_some() {
            string_data.push_str(&format!(
                "Collisions: {}\n",
                self.collisions.as_ref().unwrap()
            ));
        }
        if self.video_aspect_ratio.is_some() {
            string_data.push_str(&format!(
                "Video Aspect Ratio: {}\n",
                self.video_aspect_ratio.as_ref().unwrap()
            ));
        }
        if self.video_zoom.is_some() {
            string_data.push_str(&format!(
                "Video Zoom: {}\n",
                self.video_zoom.as_ref().unwrap()
            ));
        }
        if self.original_script.is_some() {
            string_data.push_str(&format!(
                "Original Script: {}\n",
                self.original_script.as_ref().unwrap()
            ));
        }
        if self.original_translation.is_some() {
            string_data.push_str(&format!(
                "Original Translation: {}\n",
                self.original_translation.as_ref().unwrap()
            ));
        }
        if self.original_editing.is_some() {
            string_data.push_str(&format!(
                "Original Editing: {}\n",
                self.original_editing.as_ref().unwrap()
            ));
        }
        if self.original_timing.is_some() {
            string_data.push_str(&format!(
                "Original Timing: {}\n",
                self.original_timing.as_ref().unwrap()
            ));
        }
        if self.synch_point.is_some() {
            string_data.push_str(&format!(
                "Synch Point: {}\n",
                self.synch_point.as_ref().unwrap()
            ));
        }
        if self.script_updated_by.is_some() {
            string_data.push_str(&format!(
                "Script Updated By: {}\n",
                self.script_updated_by.as_ref().unwrap()
            ));
        }
        if self.update_details.is_some() {
            string_data.push_str(&format!(
                "Update Details: {}\n",
                self.update_details.as_ref().unwrap()
            ));
        }
        if self.ycbcr_matrix.is_some() {
            string_data.push_str(&format!(
                "YCbCr Matrix: {}\n",
                self.ycbcr_matrix.as_ref().unwrap()
            ));
        }

        write!(f, "{}", string_data.trim())
    }
}

impl FromStr for ScriptInfo {
    type Err = MalformedScriptInfoError;

    fn from_str(script_info_string: &str) -> Result<Self, Self::Err> {
        let mut script_info = ScriptInfo::default();
        for line in script_info_string.trim().lines().skip(1) {
            // Skipping [Script Info]
            if line.starts_with(';') {
                if script_info.comments.is_none() {
                    script_info.comments = Some(String::from(line.trim()));
                } else {
                    script_info.comments = Some(format!(
                        "{}\n{}",
                        script_info.comments.unwrap_or(String::from("")),
                        line.trim()
                    ));
                }
            } else if line.contains(':') {
                let (line_property, line_value) = line.split_once(": ").unwrap();

                match line_property {
                    "Title" => script_info.title = Some(String::from(line_value)),
                    "ScriptType" => script_info.script_type = Some(String::from(line_value)),
                    "WrapStyle" => script_info.wrap_style = Some(line_value.trim().parse()?),
                    "PlayResX" => script_info.play_res_x = Some(line_value.trim().parse()?),
                    "PlayResY" => script_info.play_res_y = Some(line_value.trim().parse()?),
                    "ScaledBorderAndShadow" => {
                        script_info.scaled_border_and_shadow = Some(line_value == "yes")
                    }
                    "Collisions" => script_info.collisions = Some(String::from(line_value)),
                    "Video Aspect Ratio" => {
                        script_info.video_aspect_ratio = Some(line_value.trim().parse()?)
                    }
                    "Video Zoom" => script_info.video_zoom = Some(line_value.trim().parse()?),
                    "Original Script" => {
                        script_info.original_script = Some(String::from(line_value))
                    }
                    "Original Translation" => {
                        script_info.original_translation = Some(String::from(line_value))
                    }
                    "Original Editing" => {
                        script_info.original_editing = Some(String::from(line_value))
                    }
                    "Original Timing" => {
                        script_info.original_timing = Some(String::from(line_value))
                    }
                    "Synch Point" => script_info.synch_point = Some(line_value.trim().parse()?),
                    "Script Updated By" => {
                        script_info.script_updated_by = Some(String::from(line_value))
                    }
                    "Update Details" => script_info.update_details = Some(String::from(line_value)),
                    "YCbCr Matrix" => script_info.ycbcr_matrix = Some(String::from(line_value)),
                    &_ => log::warn!(
                        "Ignoring unknown [Script Info] property ({})",
                        line_property
                    ),
                }
            }
        }
        Ok(script_info)
    }
}
